;;;; algebra.lisp


(defun dot-product (vector1 vector2)
  (do ((index 0 (1+ index))
       (sum 0))
      ((= index (length vector1 )) sum)
    (incf sum (* (elt vector1 index)
		 (elt vector2 index)))))

(defun square-matrix-p (matrix)
  "Returns wheter or not a matrix is square."
  (let ((height (length matrix)))
    (do ((row 0 (1+ row)))
	((= row height) t)
      (if (not (= (length (elt matrix row))
		  height))
	  (return-from square-matrix-p)))))

(defun determinant (matrix)
  (if (and (square-matrix-p matrix)
	   (= 2 (length matrix)))
      (-
       (* (elt (elt matrix 1) 0)
	  (elt (elt matrix 2) 1))
       (* (elt (elt matrix 1) 1)
	  (elt (elt matrix 2) 0)))))

(defun cross-product (vector1 vector2)
  (assert (= 3 (length vector1) (length vector2)))
  (+
   (- (* (elt vector1 1)
	 (elt vector2 2))
      (* (elt vector1 2)
	 (elt vector2 1)))
   (* -1
      (- (* (elt vector1 0)
	    (elt vector2 2))
	 (* (elt vector1 2)
	    (elt vector2 0))))
   (- (* (elt vector1 0)
	 (elt vector2 1))
      (* (elt vector1 1)
	 (elt vector2 0)))))




(defun integrate (funct var &optional start end)
  ;;Symbolic Integration
  funct
  var
  ;;Definite Evaluation
  (if (or start end)
      (print t)))



(defparameter functions
  `(+ - / * log sqrt exp expt sin cos tan summation integrate lim))

(defun var-p (symbol)
  (not (or (numberp symbol)
	   (find symbol functions))))

(defun has-vars-p (tree)
  "Whether or not a lisp tree has variables (as opposed to explicit values)."
  (assert (not (eql tree nil)))
  (dolist (node tree nil)
    (if (listp node)
	(if (has-vars-p node)
	    (return-from has-vars-p t))
	(if (var-p node)
	  (return-from has-vars-p t)))))

(deftest test-has-vars ()
  (check
   (eql (has-vars-p '(+ 1 2 3)) nil)
   (eql (has-vars-p '(1)) nil)
   (eql (has-vars-p '(+ 2 'x)) t)
   (eql (has-vars-p '(+ (+ 1 'x) (- 3 4))) t)
   (eql (has-vars-p '(/ (log 1 2) (expt 7 3))) nil)
   (eql (has-vars-p '(expt 12 (+ 2 4 (- 89 (/ 1 2 'x))))) t)))

(defun replace-var (tree var value)
  (assert (not (eql tree nil)))
  (dotimes (index (length tree) tree)
    (let ((node (elt tree index)))
      (if (listp node)
	  (replace-var node var value)
	  (if (equal var node)
	      (progn
		(setf (elt tree index) value)))))))

(deftest test-replace-var ()
  (check
   (equal (replace-var '(x) 'x 1)
	  '(1))
   (equal (replace-var '(x) 'q 13)
	  '(x))
   (equal (replace-var '(+ 1 2 3) 'x 72)
	  '(+ 1 2 3))
   (equal (replace-var '(+ x 1 2 3 x) 'x 24)
	  '(+ 24 1 2 3 24))
   (equal (replace-var '(1) 'z 'y)
	  '(1))
   (equal (replace-var '(z) 'z 'y)
	  '(y))
   (equal (replace-var '(+ 2 'x) 'x 60)
	  '(+ 2 60))
   (equal (replace-var '(+ (+ 1 'x) (- 3 4)) 'x -7)
	  '(+ (+ 1 -7) (- 3 4)))
   (equal (replace-var '(/ (log 1 2) (expt 7 3)) 'w 'lel)
	  '(/ (log 1 2) (expt 7 3)))
   (equal (replace-var '(/ (log 1 2) w (expt 7 3) w) 'w 'lel)
	  '(/ (log 1 2) lel (expt 7 3) w))
   (equal (replace-var '(expt 12 (+ 2 4 (- 89 (/ 1 2 'x)))) 'x '(log 10 y))
	  '(expt 12 (+ 2 4 (- 89 (/ 1 2 (log 10 'y))))))))

(defun replace-vars (tree vars values)
  (assert (not (eql tree nil)))
  (assert (= (length vars) (length values)))
  (dotimes (index (length tree) tree)
    (let ((node (elt tree index)))
      (if (listp node)
	  (replace-vars node vars values)
	  (let ((pos (position node vars)))
	    (if pos
		(setf (elt tree index)
		      (elt values pos))))))))

(deftest test-replace-vars ()
  (check
   (equal (replace-vars '(x) '(x) '(1))
	  '(1))
   (equal (replace-vars '(x) '(y) '(13))
	  '(x))
   (equal (replace-vars '(+ 1 2 3) '(x) '(72))
	  '(+ 1 2 3))
   (equal (replace-vars '(+ x 1 2 3 x) '(x) '(24))
	  '(+ 24 1 2 3 24))
   (equal (replace-vars '(1) '(x) '(y))
	  '(1))
   (equal (replace-vars '(x) '(x) '(y))
	    '(y))
   (equal (replace-vars '(+ 2 'x) '(x) '(60))
	  '(+ 2 60))
   (equal (replace-vars '(+ (+ 1 'x) (- 3 4)) '(x) '(-7))
	  '(+ (+ 1 -7) (- 3 4)))
   (equal (replace-vars '(/ (log 1 2) (expt 7 3)) '(x) '(lel))
	  '(/ (log 1 2) (expt 7 3)))
   (equal (replace-vars '(/ (log 1 2) x (expt 7 3) y) '(x) '(lel))
	  '(/ (log 1 2) lel (expt 7 3) y))
   (equal (replace-vars '(expt 12 (+ 2 4 (- 89 (/ 1 2 'x)))) '(x) '((log 10 y)))
	  '(expt 12 (+ 2 4 (- 89 (/ 1 2 (log 10 'y))))))))

(defun simplify (tree)
  (assert tree)
  (cond
    ((or (numberp tree)
	 (symbolp tree))
     (return-from simplify tree))
    ((= 1 (length tree))
     (return-from simplify (simplify (first tree)))))
  (assert (find (first tree) functions))
  (let ((funct (first tree))
	(args (rest tree))
	newtree)
    (case funct
      (+
       (simplify-addition args))
      (*
       (simplify-mult args))
      (expt
       ;;Replace (expt (exp 1) ...) with (exp ...)
       (if (equal (simplify (first args)) '(exp 1))
	     (return-from simplify `(exp ,(simplify (second args))))))
      (exp
       (return-from simplify `(exp ,(simplify (first args))))))))

(deftest test-simplify ()
  (check
   (equal (simplify '(+ x))
	  'x)
   (equal (simplify '(+ 7))
	  7)
   (= (simplify '(+ 7 3))
      10)
   (= (simplify '(* 2 3))
      6)
   (equal (simplify '(+ 1 x))
	  '(+ 1 x))))

(defun simplify-addition (args)
  (if (= (length args) 1)
      (return-from simplify-addition (simplify (first args))))
  (let ((symbol-hash (make-hash-table :size (length args)))
	(list-hash (make-hash-table :size (length args)))
	num-stack
	newtree
	(only-nums t))
    (dolist (node args)
      (let ((val (simplify node)))
	(cond
	  ((listp val)
	   (if (eql '+ (first val))
	       (return-from simplify-addition
		 (simplify `(+ ,(splice-funct '+ args))))
	       (let ((s-val (simplify val)))
		 (setf only-nums nil)
		 (if (gethash s-val list-hash)
		     (incf (gethash val list-hash))
		     (setf (gethash val list-hash) 1)))))
	  ((symbolp val)
	   (if (gethash val symbol-hash)
	       (incf (gethash val symbol-hash))
	       (setf (gethash val symbol-hash) 1)))
	  ((numberp val)
	   (push val num-stack)))))
    (push '+ num-stack)
    (let ((sum (eval num-stack)))
      (if only-nums
	  (return-from simplify-addition sum)
	  (push sum newtree)))
    (maphash #'(lambda (key value)
		 (push `(* ,value ,key) newtree)) symbol-hash)
    (maphash #'(lambda (key value)
		 (push `(* ,value ,key) newtree)) list-hash)
    (push '+ newtree)))

(defun splice-funct (funct args)
  (let (newlist)
    (dolist (node args)
      (if (and (listp node)
	       (eql funct (first node)))
	  (setf newlist (append newlist (rest node)))
	  (setf newlist (append newlist (list node)))))
    newlist))

(deftest test-splice ()
  (check
   (equal (splice-funct '+ '(1 2 (+ 3 4) (+ 5 6)))
	  '(1 2 3 4 5 6))
   (equal (splice-funct '* '(1 2 (* 3 4) (* 5 6)))
	  '(1 2 3 4 5 6))
   (equal (splice-funct '+ '(1 2 (* 3 4) (* 5 6)))
	  '(1 2 (* 3 4) (* 5 6)))
   (equal (splice-funct '+ '(1 2 (+ 3 4) (* 5 6)))
	  '(1 2 3 4 (* 5 6)))
   (equal (splice-funct '* '(1 2 (+ 3 4) (* 5 6)))
	  '(1 2 (+ 3 4) 5 6))))

(defun simplify-mult (args)
  (print "simplify-mult")
  (print args)
  (if (= (length args) 1)
      (return-from simplify-mult (simplify (first args))))
  (let ((symbol-hash (make-hash-table :size (length args)))
	(list-hash (make-hash-table :size (length args)))
	num-stack
	newtree)
    (dolist (node args)
      (let ((val (simplify node)))
	(cond
	  ((listp val)
	   (if (eql '* (first val))
	       (return-from simplify-mult (simplify (splice-funct '+ args)))
	       (let ((s-val (simplify val)))
		 (if (gethash s-val list-hash)
		     (incf (gethash val list-hash))
		     (setf (gethash val list-hash) 1)))))
	  ((symbolp val)
	   (if (gethash val symbol-hash)
	       (incf (gethash val symbol-hash))
	       (setf (gethash val symbol-hash) 1)))
	  ((numberp val)
	   (push val num-stack)))))
    (push '* num-stack)
    (push (eval num-stack) newtree)
    (maphash #'(lambda (key value)
		 (push `(* ,value ,key) newtree)) symbol-hash)
    (maphash #'(lambda (key value)
		 (push `(* ,value ,key) newtree)) list-hash)
    (push '* newtree)))

(defun equivalent-p (tree &rest trees)
  (assert (not (or (eql nil tree)
		   (eql nil trees))))
  (let* ((tree2 (first trees))
	 (args (rest tree))
	 (args2 (rest tree2))
	 (funct (first tree))
	 (funct2 (first tree2))
	 equivalent)
    (if (listp tree)
	(progn
	  (assert (and (find (first tree) functions)
		       (find (first tree2) functions)))
	  (case funct
	    ((+ *)
	     (let ()
	       (if (and (eql funct funct2)
			(same-quantities args args2))
		   (setf equivalent t)))))))
    (if equivalent
	(let ((other-trees (rest trees)))
	  (if other-trees
	      (equivalent-p tree other-trees)
	      t)))))

(defun print-hash (key value)
  (format t "~%~a :: ~a" key value))

(defun tables-equal (table1 table2)
  (maphash #'(lambda (key value)
	       (let ((otherval (gethash key table2)))
		 (if (not (equal value otherval))
		     (return-from tables-equal))))
	   table1)
  t)

(defun same-quantities (list1 list2)
  (let ((len1 (length list1))
	(len2 (length list2)))
    (if (not (= len1 len2))
	nil
	(let ((hash (make-hash-table :size len1))
	      (hash2 (make-hash-table :size len1))
	      (list-hash (make-hash-table :size len1 :test 'equal))
	      (list-hash2 (make-hash-table :size len1 :test 'equal)))
	  (dolist (node list1)
	    (let (table)
	      (if (listp node)
		  (setf table list-hash)
		  (setf table hash))
	      (if (eql nil (gethash node table))
		  (setf (gethash node table) 1)
		  (incf (gethash node table)))))
	  (dolist (node list2)
	    (let (table)
	      (if (listp node)
		  (setf table list-hash2)
		  (setf table hash2))
	      (if (eql nil (gethash node table))
		  (setf (gethash node table) 1)
		  (incf (gethash node table)))))
	  (and (tables-equal hash hash2)
	       (tables-equal list-hash list-hash2))))))

(deftest test-same-quantities ()
  (check
   (same-quantities '(x) '(x))
   (same-quantities '(1 2 3 4) '(1 2 3 4))
   (same-quantities '(1 2 3 (5 4 3)) '(1 2 3 (5 4 3)))
   (same-quantities '(+ - 4 x) '(x - + 4))
   (not (same-quantities '(lol lel kek lmao) '(lel kek lmao lel lol)))
   (same-quantities '(5 6 (3 4 5) (3 4 5) (3 4 5) (1 2))
		    '(5 6 (3 4 5) (3 4 5) (3 4 5) (1 2)))
   (not (same-quantities '(5 6 (3 4 5) (4 5) (3 4 5) (1 2))
			 '(5 6 (3 4 5) (3 4 5) (3 4 5) (1 2))))))

(defun count-atoms (tree)
  "Counts the atoms in a list and its sublists to give an idea of the complexity 
of an expression."
  (assert (listp tree))
  (let ((total 0))
    (dolist (node tree)
      (if (listp node)
	  (incf total (count-atoms node))
	  (incf total)))
    total))

